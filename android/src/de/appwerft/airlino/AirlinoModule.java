/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2010 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package de.appwerft.airlino;

import java.net.InetAddress;

import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.KrollFunction;
import org.appcelerator.kroll.KrollModule;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.kroll.common.Log;
import org.appcelerator.titanium.TiApplication;

import android.app.Activity;
import android.content.Context;
import android.net.nsd.NsdManager;
import android.net.nsd.NsdServiceInfo;

@Kroll.module(name = "Airlino", id = "de.appwerft.airlino")
public class AirlinoModule extends KrollModule {
	private static final String LCAT = "AirLino ðŸ˜ˆ";
	Context ctx;
	NsdManager nsdManager;
	private KrollFunction onSuccessCallback = null;
	private KrollFunction onErrorCallback = null;
	private KrollFunction onResultCallback = null;
	private boolean isPingActive = false;
	String DNSTYPE = "_dockset._tcp.";
	String host = null;
	String port = null;
	String endpoint = null;
	int scanTimeout = 2000;
	int pingTimeout = 2000;
	AirlinoDevices aDevices = new AirlinoDevices();

	public NsdManager.ResolveListener resolveListener;
	public NsdManager.DiscoveryListener discListener = null;
	private Activity activity;

	public AirlinoModule() {
		super();
		activity = TiApplication.getInstance().getRootOrCurrentActivity();
		/*
		 * When your application finds a service on the network to connect to,
		 * it must first determine the connection information for that service,
		 * using the resolveService() method. Implement a
		 * NsdManager.ResolveListener to pass into this method, and use it to
		 * get a NsdServiceInfo containing the connection information.
		 */
		resolveListener = new NsdManager.ResolveListener() {
			@Override
			public void onResolveFailed(NsdServiceInfo serviceInfo,
					int errorCode) {
				// Called when the resolve fails. Use the error
				// code to debug.
				Log.e(LCAT, "Resolve failed" + errorCode);
			}

			@Override
			public void onServiceResolved(NsdServiceInfo serviceInfo) {
				Log.d(LCAT, "Resolve Succeeded. " + serviceInfo);
				if (onSuccessCallback != null) {
					Log.e(LCAT, "callback prep. ");
					KrollDict event = parseNsdServiceInfo(serviceInfo);
					if (isPingActive) {
						KrollDict result = new KrollDict();
						result.put("result", true);
						isPingActive = false;
						stopDiscoveryListener();
						onResultCallback.call(getKrollObject(), result);
					} else {
						onSuccessCallback.call(getKrollObject(), event);
					}
				} else
					Log.w(LCAT, " no callback found");
			}
		};
	}

	@Kroll.onAppCreate
	public static void onAppCreate(TiApplication app) {
	}

	/*
	 * Activity Lifecycle Events Starting with Titanium SDK 4.0.0, a proxy can
	 * respond to activity lifecycle events by overriding the activity lifecycle
	 * callbacks, then in the JavaScript application, assign either a Window or
	 * TabGroup object to the proxy's lifecycleContainer property when creating
	 * the module proxy to monitor the lifecycle events of that object to
	 * trigger the module proxy's lifecycle events. First, in the module proxy,
	 * override the activity lifecycle callbacks you want to respond to, such as
	 * onCreate, onStart, onRestart, onResume, onPause, onStop or onDestroy.
	 */

	// following
	// https://github.com/appcelerator-modules/ti.moddevguide/blob/master/android/src/ti/moddevguide/ModdevguideModule.java
	@Override
	public void onPause(Activity a) {
		tearDown();
		super.onPause(a);

	}

	@Override
	public void onResume(Activity a) {
		super.onResume(a);
		this.initializeDiscoveryListener();
	}

	private void tearDown() {
		if (discListener != null)
			nsdManager.stopServiceDiscovery(discListener);
	}

	public void onDestroy() {
		tearDown();
	}

	@Kroll.method
	public void isAvailable(KrollDict opt) {
		Object callback;
		if (opt.containsKeyAndNotNull("onResult")) {
			callback = opt.get("onResult");
			if (callback instanceof KrollFunction) {
				onResultCallback = (KrollFunction) callback;
			} else
				Log.w(LCAT, "onSuccessFn missed");
		} else
			Log.w(LCAT, "onSuccess missed");
		if (opt.containsKeyAndNotNull("timeout")) {
			scanTimeout = opt.getInt("timeout");
		}
		isPingActive = true;
		this.initializeDiscoveryListener();
	}

	@Kroll.method
	public void startScan(KrollDict opt) {
		Object callback;
		if (opt.containsKeyAndNotNull("onSuccess")) {
			callback = opt.get("onSuccess");
			if (callback instanceof KrollFunction) {
				onSuccessCallback = (KrollFunction) callback;
			} else
				Log.w(LCAT, "onSuccessFn missed");
		} else
			Log.w(LCAT, "onSuccess missed");
		if (opt.containsKeyAndNotNull("onError")) {
			callback = opt.get("onFound");
			if (callback instanceof KrollFunction) {
				onErrorCallback = (KrollFunction) callback;
			}
		}
		if (opt.containsKeyAndNotNull("timeout")) {
			scanTimeout = opt.getInt("timeout");
		}
		this.initializeDiscoveryListener();

	}

	private void stopDiscoveryListener() {

		try {
			nsdManager.stopServiceDiscovery(discListener);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	private void initializeDiscoveryListener() {
		ctx = TiApplication.getInstance().getApplicationContext();
		nsdManager = (NsdManager) ctx.getSystemService(Context.NSD_SERVICE);
		discListener = new NsdManager.DiscoveryListener() {
			@Override
			public void onDiscoveryStarted(String regType) {
				Log.d(LCAT, "Service discovery started");

			}

			/* a new device is found */
			@Override
			public void onServiceFound(NsdServiceInfo service) {
				nsdManager.resolveService(service, resolveListener);
			}

			/* a device is lost */
			@Override
			public void onServiceLost(NsdServiceInfo service) {
				if (onErrorCallback != null)
					onErrorCallback.call(getKrollObject(),
							parseNsdServiceInfo(service));
			}

			@Override
			public void onDiscoveryStopped(String serviceType) {
				Log.i(LCAT, "Discovery stopped: " + serviceType);
			}

			@Override
			public void onStartDiscoveryFailed(String serviceType, int errorCode) {
				Log.e(LCAT, "Discovery failed: Error code:" + errorCode);
				nsdManager.stopServiceDiscovery(this);
			}

			@Override
			public void onStopDiscoveryFailed(String serviceType, int errorCode) {
				Log.e(LCAT, "Discovery failed: Error code:" + errorCode);
				nsdManager.stopServiceDiscovery(this);
			}
		};
		nsdManager.discoverServices(DNSTYPE, NsdManager.PROTOCOL_DNS_SD,
				discListener);

		new android.os.Handler().postDelayed(new Runnable() {
			public void run() {
				if (isPingActive) {
					stopDiscoveryListener();
					if (onResultCallback != null) {
						KrollDict result = new KrollDict();
						result.put("result", false);
						onResultCallback.call(getKrollObject(), result);
					}
					isPingActive = false;
				}

				Log.d(LCAT, "discoveryService ended after " + scanTimeout
						+ " seconds.");
			}
		}, (isPingActive) ? pingTimeout : scanTimeout);
	}

	private KrollDict parseNsdServiceInfo(NsdServiceInfo so) {
		endpoint = "http://";
		KrollDict dict = new KrollDict();
		Log.d(LCAT, so.toString());
		Log.d(LCAT, "============");
		InetAddress address = so.getHost();
		if (address != null) {
			dict.put("ip", address.getHostAddress());
			endpoint += address.getHostAddress();
		}
		dict.put("port", so.getPort());
		endpoint += (":" + so.getPort() + "/api/v15/radio.action");
		dict.put("name", so.getServiceName());
		dict.put("endpoint", endpoint);
		Log.d(LCAT, dict.toString());
		return dict;
	}
}
